- DO NOT WRITE ESSAYS, DO NOT GIVE HIGH LEVEL TIPS, DO NOT SPAM ENDLESS EXPLANATIONS. SIMPLY IMPLEMENT THE FIX OR FEATURE REQUESTED!!!!!!!!!!!!!!!

- Use [Feature-Sliced Design](https://feature-sliced.design/docs/get-started/overview):

rules:
  - ruleType: Always
    description: Feature‑Sliced Design architecture guidelines
    instructions: |
      We follow Feature‑Sliced Design (FSD). The structure has six layers: app, processes, pages, features, entities, and shared.  
      • Each layer contains “slices” (folders in kebab‑case) that group related functionality.  
      • Slices must not depend on other slices in the same or higher layer (isolation).  
      • Every slice exposes a public API at its root via an index.ts(x)/js(x).  
      • Shared UI components go into shared; business logic flows (state orchestration) go into processes; page‑scoped UIs into pages; features into features; core data types into entities; and application bootstrap into app.  
  - ruleType: AutoAttached
    filePatterns:
      - "app/**"
      - "processes/**"
      - "pages/**"
      - "features/**"
      - "entities/**"
      - "shared/**"
    description: Enforce slice context
    instructions: |
      For any file under these paths:  
      1. Identify the slice as the first directory under the layer.  
      2. Import only from that slice’s public API (`index.ts(x)`), not deep paths.  
      3. Within a slice, organize code into segments (e.g. model, ui, api, types).  
      4. Keep layer‑specific concerns in their layer only.  
  - ruleType: AutoAttached
    filePatterns:
      - "**/index.ts"
      - "**/index.tsx"
      - "**/index.js"
      - "**/index.jsx"
    description: Public API entrypoints
    instructions: |
      Treat these as the canonical API surface for their slice or layer.  
      When generating imports or edits, always prefer these entrypoints over internal files.  



- Use Tailwind + Daisy UI for styling
  - Ensure that the layout works on mobile and desktop. Keep in mind both light and dark mode, avoid hardcoding white, greys and blacks.
- follow Vue3/ts best practices
- Our interfaces (and their implementation, currently dexie)

- Page components should include MINIMAL implementation logic. That should live in util functions, called from components, not pages.
- Components are either controller (logic, maybe dependency and store, do nothing in template except loading a representational component) or representational only (just props and emits, no external dependencies)
- keep code unit-testable as much a possible
- fix linter errors always
- do not replicate type files! types should always live in dedicated files (unless ONLY relevant hyper-locally), and existing types should be reused.
- use lucide icons (lucide-vue-next). Ensure!! icon names are valid ([icon list](https://raw.githubusercontent.com/mazeincoding/lucide-icons-list/refs/heads/main/icons.txt))

- do NOT run `npm run dev`. It's annoying and useless.

## How to Add a Feature

### High-Level Organisation

As a rule:

- Open an issue (work towards an issue)
- make a branch

### Development

- Add unit tests via the configured `vitest` environment
  - It's not required to use TDD, but it may make sense, especially when working on logic-heave features
  - However, each added feature should at least be convered in regards to basic happy path

- Keep files reasonably small.
- Write VERY CLEAN code. functions and lines of code should be self-explanatory. If a collection of code lines is confusing to read (or even just a single line), it should likely be its own function
- Keep components and pages as purely representational as possible

- Types and interfaces live in `/types` unless they are 100% only usable in one file or page. Do NOT, EVER, copypaste types in component files

- ALWAYS use `@/...` import syntax, except if the the imported thing is in the same directory. That's way more robust, and way more readable.

### Documentation

- Write conceptual stuff in `docs/` as a markdown guide
- Code should mostly document itself, see chapter above
- Use JsDoc style annotation, but ONLY!! to explain purpose or non-obvious decisions. Do NOT! JS-Doc annotate params or returns, that is *already done* by typescript. Keep it short. Explain how the code fits into the bigger picture.
- Avoid! just reiterating the name of a function (or whatever), e.g. we do not want to see `downloadLatestLessons() // downloads the latest lessons`. That is wasteful. Focus on purpose and how it ties in!

### Testing

- Write unit tests, component test and integration test when it's useful to improve our confidence
- Test files should live alongside the code they are testing

### Tech Stack

- Standard Vue + Vite app
    - Meaning, per-default, we are doing things *server-side*
- `eslint` is setup. Don't forget to run linter.
- we have `Tailwind` + `Daisy UI` installed, utilize that for design
    - Avoid manual CSS when possible
