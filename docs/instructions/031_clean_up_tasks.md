Let's clean up tasks.

- I updated [TaskData] to optionally directly associate uids of vocab, fact cards, resources and goals. This replaces the previous, now deleted awkward prop `associatedUnits`. Please adapt usages and dexie. No backwards compatibility.
- No task renderer (anything in [this folder](src/tasks)) should EVER handle their own rating, skipping or fuck around with its task data. This should be handled in a standardized way by the [TaskRenderer](src/widgets/do-task/TaskRenderer.vue)

## TaskRenderer

Some more details then on what exactly `TaskRenderer` should do:

- At the start, render the task using the correct widget and display the `title` and `prompt` in a designated area above the actual task.
- In this area, also allow `Not Now` `Skip and deactivate` and `Done`. Simply use the dumb component `src/widgets/do-task/ui/TaskButtonsDisableSkipDone.vue`. Handle these accordingly. Of course, the already implemented `mayBeConsideredDone` logic should be adhered to and determine whether the the `Done` button is even enabled.
- After the task is done, we do the following:
- *If* the `TaskData` has `evaluateDifficultyAfterDoing = true`, replace the component with the done/skip buttons and so on with `src/widgets/do-task/ui/TaskEvaluateDifficulty.vue` (warning: prop ws renamed). This is another dumb component, which should only use props/emits. It also currently is massively over-designed with a million features and headings and card. vastly simplify it to show only "How difficult was this task?" and four buttons "Impossible", "Difficult", "Doable", "Easy". Simply wait for a click on any of these buttons and go to the next step.
- If the rating above is done, or it was not part of the task, now check if `decideWhetherToDoAgainAfterDoing` is true on the task data. If so, render the `src/widgets/do-task/ui/TaskDecideWhetherToDoAgain.vue` component where the done/skip buttons where. Again, component should be dumb, and events received by the Task Renderer
- Note: it may be that neither of the two is true, or both. If none was true, do not show these components, simply go to the next step


- After the task is done and any rating/deciding whether to do again is also done, `TaskRenderer` communicates with the [task repo](/home/brokkoli/GITHUB/linguanodon/src/entities/tasks/TaskRepoContract.ts) to actually update the task.
- If `TaskData` `isOneTime` is true (warning: new prop, adapt dexie and generation), set `isActive` to false
- If you got data from `decideWhetherToDoAgainAfterDoing`, also set `isActive` accordingly
- Set `lastShownAt` to the correct time stamp
- If you got data from `evaluateDifficultyAfterDoing`, set that value accordingly
- Note: we're using `Rating` from [ts-fsrs](node_modules/ts-fsrs/dist/index.d.ts) here. Research how that is used, do not hallucinate. Ideally, already integrate that in the buttons from the rating widget

Also, the `TaskData` may have associated entities. Treat them as follows

### Vocab Data

If `TaskData` has non-empty, existing `associatedVocab`, loop them and for each:

- *If* the task we just did `isOneTime`, only set the `VocabData.progress.last_review` to now. Use an entity function for that, encapsualting it!!
- *If* the task we just did was *not* one time and we got a diffulty rating, use the `scoreVocab` function from [the vocab contract](src/entities/vocab/VocabAndTranslationRepoContract.ts) to actually score the vocab itself. (note: I changed the function props, fix in the entity repo implementation)

### Fact Card Data

If we have attached fact card data, handle it exactly the same way as above, just for [FactCard](src/entities/factCards/FactCardData.ts) and its [repo](src/entities/factCards/FactCardRepoContract.ts), which is also as of yet missing functions

### Goal Data / Resource Data

If we attached uids for these, update the [ResourceData](src/entities/resources/ResourceData.ts) and or [GoalData](src/entities/goals/GoalData.ts)'s `lastShownAt` (note: for goals this prop is new, update repo and dexie)

## Task Creation

- Tasks should EXCLUSIVELY generated by features such as [this](src/features/resource-update-tasks) and [this](src/features/goal-update-tasks) and persisted to the task repo. Absolutely NO inline generation of tasks anywhere else!


# Clarification Questions

1. **TaskEvaluateDifficulty Component**: The current implementation has both correctness and difficulty ratings. Should I simplify to only difficulty rating with "Impossible", "Difficult", "Doable", "Easy" buttons that map to ts-fsrs Rating enum (Again=1, Hard=2, Good=3, Easy=4)?

yes, simplify to the specified buttons and map them to the ts-fsrs rating enum in the obvious way: impossible=again, difficult=hard, and so on

2. **Missing FactCard Repository Functions**: The FactCardRepoContract is missing `scoreFactCard()` and `updateLastReview()` functions mentioned in the requirements. Should I add these following the same pattern as VocabAndTranslationRepoContract?

yep, add

3. **GoalData lastShownAt Property**: This property is mentioned as new but doesn't exist in the current GoalData interface. Should I add it and update the corresponding Dexie schema?

It does in fact exist. I just added it [GoalData](src/entities/goals/GoalData.ts). Yes, update relevant code

4. **Legacy associatedUnits Property**: Task generation code still uses the old `associatedUnits` structure (e.g., in UpdateResourceTasksController.ts:78). Should I update all task generation to use the new associatedVocab/Resources/FactCards/Goals arrays instead?

yes, update all to new data paradigm.

5. **TaskData isOneTime Property**: This is mentioned as a new property but needs to be added to the schema. Should I also update the Dexie database schema and migration logic?

yes

6. **VocabAndTranslationRepoContract.scoreVocab**: The instructions mention "I changed the function props, fix in the entity repo implementation" - what specific changes were made to the function signature that need to be implemented?

I used the proper `Rating` type instead of some dumb hack

7. **Task Component Event Handling**: Should I remove ALL custom event handling from individual task components (like @taskWasDone, @taskNowMayBeConsideredDone) and centralize everything in TaskRenderer?

yes, remove HANDLING of these events in tasks/. but of course, the task components still have to *emit* these events so that `TaskRenderer` may react

8. **Entity Function Encapsulation**: For updating VocabData.progress.last_review, should I create a specific entity method or can I update the property directly in the repository?

add a specific entity method for this in both fact card and vocab repo.